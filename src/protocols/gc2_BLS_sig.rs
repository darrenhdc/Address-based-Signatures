  
extern crate bn;
extern crate rand;
use bn::{Group, Fr, G1, G2, pairing};
use rand::{Rng,SeedableRng,StdRng};

use curv::cryptographic_primitives::hashing::traits::Hash;
use curv::cryptographic_primitives::hashing::hash_sha256::HSha256;
use curv::BigInt;
use curv::{FE, GE};


#[derive(Clone)]
pub struct gc2_BLS_Setup {
    x: Fr, // sk
    pub X: G1, // pk
    pub A: BigInt,
}

#[derive(Clone)]
pub struct gc2_BLS_Signature {
    pub sigma: G2,
}

pub fn H_G2(m: &BigInt) -> G2 {
        // according to: https://tools.ietf.org/id/draft-kasamatsu-bncurves-01.html
        // p2 = order of the group generated by G2
        let p2: BigInt = str::parse(
            "16030569034403128277756688287498649515510226217719936227669524443298095169537"
        )
        .unwrap();
        let exp: Fr = Fr::from_str(&crate::string_to_static_str(
            HSha256::create_hash(
            &[&m,]
        )
        .mod_floor(&p2)
        .to_str_radix(10)))
        .unwrap();
        let result = G2::one() * exp;
        result
}

impl gc2_BLS_Setup{
    pub fn keygen() -> Self {
        let rng = &mut rand::thread_rng();
        let x = Fr::random(rng);
        let X = G1::one() * x; // pk = g1^sk
        let X_hex = crate::into_hex(X).unwrap();
        let two_pow_160 = BigInt::ui_pow_ui(2, 160);
        let A = HSha256::create_hash(&[
            &BigInt::from_str_radix(
                &crate::string_to_static_str(X_hex),
                16,
            )
            .unwrap(),
        ])
        .mod_floor(&two_pow_160);
        Self {
            x, // sk
            X, // pk
            A,
        }
    }
    
    pub fn sign(
        &self,
        m: &BigInt
    ) -> gc2_BLS_Signature {
        let sigma = H_G2(m) * self.x;
        gc2_BLS_Signature {
            sigma
        }
    }

    pub fn verify(   
        X: G1,
        sig: &gc2_BLS_Signature,
        m: &BigInt,
        A: &BigInt,
    ) -> bool  {
        let mut flag = true;

        let X_hex = crate::into_hex(X).unwrap();
        let two_pow_160 = BigInt::ui_pow_ui(2, 160);
        let A_recover = HSha256::create_hash(&[
            &BigInt::from_str_radix(
                &crate::string_to_static_str(X_hex),
                16,
            )
            .unwrap(),
        ])
        .mod_floor(&two_pow_160);

        if pairing(G1::one(), sig.sigma) != pairing(X, H_G2(m)) ||
        &A_recover != A
        {
            flag = false
        }
        assert_eq!(flag, true, "verify fialed.");
        flag

    }
}

