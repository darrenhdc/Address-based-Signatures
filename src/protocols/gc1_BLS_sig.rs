  
extern crate bn;
extern crate rand;
use bn::{Group, Fr, G1, G2, pairing};
use rand::{Rng,SeedableRng,StdRng};

use curv::cryptographic_primitives::hashing::traits::Hash;
use curv::cryptographic_primitives::hashing::hash_sha256::HSha256;
use curv::BigInt;
use curv::{FE, GE};


#[derive(Clone)]
pub struct gc1_BLS_Setup {
    x: Fr, // sk
    pub X: G1, // pk
    pub A: std::string::String,
}

#[derive(Clone)]
pub struct gc1_BLS_Signature {
    pub sigma: G2,
}

pub fn H_G2(m: &BigInt) -> G2 {
        // according to: https://tools.ietf.org/id/draft-kasamatsu-bncurves-01.html
        // p2 = order of the group generated by G2
        let p2: BigInt = str::parse(
            "16030569034403128277756688287498649515510226217719936227669524443298095169537"
        )
        .unwrap();
        let exp: Fr = Fr::from_str(&crate::string_to_static_str(
            HSha256::create_hash(
            &[&m,]
        )
        .mod_floor(&p2)
        .to_str_radix(10)))
        .unwrap();
        let result = G2::one() * exp;
        result
}

impl gc1_BLS_Setup{
    pub fn keygen() -> Self {
        let rng = &mut rand::thread_rng();
        let x = Fr::random(rng);
        let X = G1::one() * x; // pk = g1^sk
        let A = crate::into_hex(X).unwrap();
        Self {
            x, // sk
            X, // pk
            A, // addr
        }
    }
    
    pub fn sign(
        &self,
        m: &BigInt
    ) -> gc1_BLS_Signature {
        let sigma = H_G2(m) * self.x;
        gc1_BLS_Signature {
            sigma
        }
    }

    pub fn verify(   
        A: &std::string::String,
        sig: &gc1_BLS_Signature,
        m: &BigInt,
    ) -> bool  {
        let mut flag = true;
        let X: G1 = crate::from_hex(&A).unwrap();
        if pairing(G1::one(), sig.sigma) != pairing(X, H_G2(m)) {
            flag = false
        }
        assert_eq!(flag, true, "verify fialed.");
        flag

    }
}

